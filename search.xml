<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[控制UIScrollView的减速速度]]></title>
      <url>%2F%E6%8E%A7%E5%88%B6ScrollView%E7%9A%84%E5%87%8F%E9%80%9F%E9%80%9F%E5%BA%A6.html</url>
      <content type="text"><![CDATA[手指在UIScrollView上滑动后，会再减速一段距离，如果觉得减速之后滑动的距离太远了，可以通过decelerationRate的值来控制减速的距离。 通过系统默认值修改系统提供以下两个值：UIScrollViewDecelerationRateNormal :正常减速UIScrollViewDecelerationRateFast：快速减速默认情况下UIScrollView使用UIScrollViewDecelerationRateNormal，如果将其改为UIScrollViewDecelerationRateFast，会发现滚动的距离明显降下来了。 self.tableView.decelerationRate = UIScrollViewDecelerationRateFast； 通过自定义值修改decelerationRate类型为CGFloat，范围是（0.0，1.0）。上面两个常量的值分别是：UIScrollViewDecelerationRateNormal :0.998UIScrollViewDecelerationRateFast：0.99 如果以上值还不能满足需求的话，我们可以将其设为范围内的任意值。比如将其设置为0.1，会发现滑动之后很快就停下来了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对产品架构的思考]]></title>
      <url>%2F%E5%AF%B9%E4%BA%A7%E5%93%81%E6%9E%B6%E6%9E%84%E7%9A%84%E6%80%9D%E8%80%83.html</url>
      <content type="text"><![CDATA[从哪些方面去思考产品架构1. 针对App 如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？ 页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？ 当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？ iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？ 2.针对团队： 收集用户数据，给产品和运营提供参考 合理地组织各业务方开发的业务模块，以及相关基础模块 每日app的自动打包，提供给QA工程师的测试工具 架构设计的方法 第一步：搞清楚要解决哪些问题，并找到解决这些问题的充要条件：清楚你要做什么，业务方希望要什么。而不是为了架构而架构，也不是为了体验新技术而改架构方案 第二步：问题分类，分模块 第三步：搞清楚各问题之间的依赖关系，建立好模块交流规范并设计模块 第四步：推演预测一下未来可能的走向，必要时添加新的模块，记录更多的基础数据以备未来之需 第五步：先解决依赖关系中最基础的问题，实现基础模块，然后再用基础模块堆叠出整个架构 第六步：打点，跑单元测试，跑性能测试，根据数据去优化对应的地方总而言之就是要遵循这些原则：自顶向下设计（1，2，3，4步），自底向上实现（5），先测量，后优化（6）。 什么样的架构是好架构？ 代码整齐，分类明确，没有common，没有core 不用文档，或很少文档，就能让业务方上手 思路和方法要统一，尽量不要多元（先确定解决思路，再开搞） 没有横向依赖，万不得已不出现跨层访问 对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件 易测试，易拓展 保持一定量的超前性 接口少，接口参数少 高性能 关于架构分层原则：自顶向下的设计方式 先确定所有要解决的问题 确定都有哪些模块 这些模块再往下细化设计 把这些列出来的问题和模块做好分类。 分类之后不出意外大多数都是三层。如果发现某一层特别庞大，那就可以再拆开来变成四层，变成五层。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《哪些知识会让你变蠢？》摘录]]></title>
      <url>%2F%E3%80%8A%E5%93%AA%E4%BA%9B%E7%9F%A5%E8%AF%86%E4%BC%9A%E8%AE%A9%E4%BD%A0%E5%8F%98%E8%A0%A2%EF%BC%9F%E3%80%8B%E6%91%98%E5%BD%95.html</url>
      <content type="text"><![CDATA[今天在一个微信公众号上看了一篇文章《哪些知识会让你变蠢？》，其中的一些文字多多少少让我构建知识体系这一命题有了更进一步的认识。 最核心的知识，只有三个 ：数学、逻辑、哲学。 知识的世界，不过是一个积木天地，有些知识是积木块，有些知识是积木场。其他的知识，都是由积木块在这个场地里搭起来的。 你认为这个世界是什么样的，就可以拿数据和逻辑这两块积木，堆砌自己的观点了。 改变网络搜索的习惯，从单纯的搜寻知识点，改为体系性搜索。你要搜索的，不是一个简单的结论，而是一个思维的完整起步。观察、分析、预判、行动、矫正、结果和反馈。 只有把你大脑里那些散乱的知识点，勾连起来构成完整的体系，这才构成知识本身。这个体系能够帮你改善你的生存环境。而不成体系的一切，都是无意义的，会让你的人生非常糟糕。 网络只是个工具。而知识，甚至不能构成工具本身，只有系统化得思想，才能构成真正意义上的工具。 互联网必将淘汰哪些低端运营者，淘汰那些只会搜索知识点的人。除非你学会运用网络构建体系，用以指导自己的人生实践。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用CAShapeLayer实现画虚线]]></title>
      <url>%2F%E4%BD%BF%E7%94%A8CAShapeLayer%E5%AE%9E%E7%8E%B0%E7%94%BB%E8%99%9A%E7%BA%BF.html</url>
      <content type="text"><![CDATA[- (void)drawRect:(CGRect)rect { CAShapeLayer *shapeLayer = [CAShapeLayer layer]; [shapeLayer setBounds:self.bounds]; [shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)]; [shapeLayer setFillColor:[UIColor clearColor].CGColor]; //设置虚线颜色 [shapeLayer setStrokeColor:[UIColor colorWithWhite:226.f/255.f alpha:1].CGColor]; //设置虚线宽度 [shapeLayer setLineWidth:self.frame.size.height]; [shapeLayer setLineJoin:kCALineJoinRound]; //设置虚线的线宽及间距 [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:1], [NSNumber numberWithInt:3], nil]]; //创建虚线绘制路径 CGMutablePathRef path = CGPathCreateMutable(); //设置虚线绘制路径起点 CGPathMoveToPoint(path, NULL, 0, 0); //设置虚线绘制路径终点 CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0); //设置虚线绘制路径 [shapeLayer setPath:path]; CGPathRelease(path); //添加虚线 [self.layer addSublayer:shapeLayer]; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView section header 不固定]]></title>
      <url>%2FUITableView-section-header-%E4%B8%8D%E5%9B%BA%E5%AE%9A.html</url>
      <content type="text"><![CDATA[iOS系统自带的UITableView，当数据分为多个section的时候，在UITableView滑动的过程中，默认section header是固定在顶部的，滑动到下一个section的时候，下一个section header把上一个section header顶出屏幕外。典型的应用就是通讯录。 默认情况下，UITableView的section header是固定的，如何让section header不固定呢？也就是随着UITableView的滑动而滑动，顶部不是一直都显示section header。方法是设置UITableView 的contentInset。代码如下： #pragma mark - scrollView代理函数 - (void)scrollViewDidScroll:(UIScrollView *)scrollView { // 修改contentSize if([scrollView isKindOfClass:[UITableView class]]){// 不固定section CGFloat sectionHeaderHeight = pxToCoordinate(TABLECELL_SECTION_HEADER); if (scrollView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;scrollView.contentOffset.y&gt;=0) { scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); } else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) { scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); } } } 原理：当滑动的值大于section header的高度时，设置其contentInset,达到不显示header的效果，这样就类似于将header给顶出了屏幕；当滑动至小于section header的高度时，恢复contentInset，显示header。 需要注意：因为UITableView 滑动时contentOffset会不断的改变，因此该部分代码需要写到 scrollViewDidScroll 方法中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[About Laying out Subviews]]></title>
      <url>%2FAbout%20Laying%20out%20Subviews.html</url>
      <content type="text"><![CDATA[layoutSubviews官方文档引用： You should override this method only if the autoresizing andconstraint-based behaviors of the subviews do not offer the behavioryou want. 我的理解是： 在subview的autoresizing和constraint不满足你的要求时，可以重写layoutSubviews。假设一个屏幕从竖屏变为横屏，本来图文单元是图片在上，文字在下面，可能就变为了左右结构；这是无论自动适配还是自动布局都解决不了，就只能重写layoutSubviews函数了。 官方文档引用: You should not call this method directly. 不应该直接调用这个方法！ 官方不建议我们直接调用layoutSubviews，其中的具体原因我想的不是特别明白，但是，我觉得可以换个角度来思考这个问题，来想想什么时候layoutSubviews会被自动调用，可能会对理解官方不建议直接调用layoutSubviews有帮助。 layoutSubviews在以下情况下会被调用： init初始化不会触发layoutSubviews,但是使用initWithFrame 进行初始化时，当rect的值不为CGRectZero时,也会触发； addSubview会触发layoutSubviews; 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化; 滚动一个UIScrollView及其派生类会触发layoutSubviews; 旋转Screen会触发父UIView上的layoutSubviews事件 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件. setNeedsLayout官方文档引用： Invalidates the current layout of the receiver and triggers a layout update during the next update cycle. Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note ofthe request and returns immediately. Because this method does notforce an immediate update, but instead waits for the next updatecycle, you can use it to invalidate the layout of multiple viewsbefore any of those views are updated. This behavior allows you toconsolidate all of your layout updates to one update cycle, which isusually better for performance. setNeedsLayout在UIView对象中设置一个标记，用来表示view需要被布局。这将使layoutSubviews方法在下一次重绘发生之前被异步调用。注意，因为UIView的autoresizesSubviews属性，在很多情况下，你不需要明确地调用setNeedsLayout，因为如果UIView的autoresizesSubviews被设置（默认被设置为YES），那么，当它的frame发生变化的时候就会自动去布局它的subViews。 此方法会将view当前的layout设置为无效的，并在下一个upadte cycle里去触发layout更新。 setNeedsLayout在以下情况下需要被调用：（帮助理解） If you manipulated constraints directly, call setNeedsLayout. If you changed some conditions (like offsets or smth) which would change constraints in your overridden updateConstraints method (a recommended way to change constraints, btw), call setNeedsUpdateConstraints, and most of the time, setNeedsLayout after that. If you need any of the actions above to have immediate effect—e.g. when your need to learn new frame height after a layout pass—append it with a layoutIfNeeded. layoutIfNeeded官方解释： Lays out the subviews immediately. Use this method to force the layout of subviews before drawing. Usingthe view that receives the message as the root view, this method laysout the view subtree starting at the root. 使用此方法强制立即进行layout,从当前view开始，此方法会遍历整个view层次(包括superviews)请求layout。因此，调用此方法会强制整个view层次布局。 如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]。 一个Demo:https://github.com/SharonHu1990/MyDemos/tree/master/LayoutSubViewsTest 在这个Demo中，一个UILabel被放在左上角，中间放一个button，点击button实现label左右移动，带有回弹动画。在xib中已经绑定了约束。 在button的action中，通过修改label的constraint.constant值实现位置的改变。代码如下： - (IBAction)touchButton:(id)sender { if (!_hasDistance) { _hasDistance = YES; _leftConstraint.constant = 100; }else{ _hasDistance = NO; _leftConstraint.constant = 0; } [UIView animateWithDuration:0.8 delay:0 usingSpringWithDamping:0.5 initialSpringVelocity:0.5 options:UIViewAnimationOptionAllowAnimatedContent animations:^{ [self.view layoutIfNeeded];//立即实现布局，如果不写这一句就没有动画效果 } completion:nil]; } 可以看到，在animations中写了[self.view layoutIfNeeded],如果没有这句代码，label只是简单地移动了位置（即只是执行了_leftConstraint.constant = XX），而没有动画效果。 setNeedsDisplay官方解释： Marks the receiver’s entire bounds rectangle as needing to be redrawn. You can use this method or the setNeedsDisplayInRect: to notify thesystem that your view’s contents need to be redrawn. This method makesa note of the request and returns immediately. The view is notactually redrawn until the next drawing cycle, at which point allinvalidated views are updated. You should use this method to request that a view be redrawn only whenthe content or appearance of the view change. 一个使用setNeedsDisplay 的例子:http://blog.fujianjin6471.com/2015/06/11/An-example-of-when-should-setNeedsDisplay-be-called.html setNeedsLayout 和 setNeedsDisplay的区别？首先两个方法都是异步执行的。而setNeedsDisplay会自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。综上所述，setNeedsDisplay方便绘图，而setNeedsLayout方便出来数据。 requiresConstraintBasedLayout官方文档： A Boolean value that indicates whether the receiver depends on theconstraint-based layout system. Custom views should override this to return YES if they cannot layoutcorrectly using autoresizing. UIView.h中是这样说的(这个解释更加帮助了理解)： constraint-based layout engages lazily when someone tries to use it(e.g., adds a constraint to a view). If you do all of your constraintset up in -updateConstraints, you might never even receiveupdateConstraints if no one makes a constraint. To fix this chickenand egg problem, override this method to return YES if your view needsthe window to use constraint-based layout. 意思就是：基于约束的布局是懒触发的(例如：给一个view添加约束)。如果把所有的约束放在 updateConstraints中，并且没有添加任何约束，那么你将不会获得updateConstraint。为了解决这个鸡和蛋的问题，重写+requiresConstraintBasedLayout 并且返回YES就是明确告诉系统：虽然我之前没有添加约束,但我确实是基于约束的布局！这样可以保证系统一定会调用 -updateConstraints 方法 从而正确添加约束. 一篇objc.io 中的文章也建议在实现使用了constraint的自定义View时，重写+requiresConstraintBasedLayout并返回YES，以声明view是依赖于AutoLayout的。 另外一篇参考文章：The Mystery of the +requiresConstraintBasedLayout translatesAutoresizingMaskIntoConstraints在代码中创建view及其派生类，如果需要给他们添加约束，就将translatesAutoresizingMaskIntoConstraints 设为NO。原因：The reason for this is that iOS creates constraints for you that match the new view’s size and position, and if you try to add your own constraints these will conflict and your app will break. 官方文档： A Boolean value that determines whether the view’s autoresizing maskis translated into Auto Layout constraints If this property’s value is YES, the system creates a set ofconstraints that duplicate the behavior specified by the view’sautoresizing mask. This also lets you modify the view’s size andlocation using the view’s frame, bounds, or center properties,allowing you to create a static, frame-based layout within AutoLayout. Note that the autoresizing mask constraints fully specify the view’ssize and position; therefore, you cannot add additional constraints tomodify this size or position without introducing conflicts. If youwant to use Auto Layout to dynamically calculate the size and positionof your view, you must set this property to NO, and then provide a nonambiguous, nonconflicting set of constraints for the view. By default, the property is set to YES for any view youprogrammatically create. If you add views in Interface Builder, thesystem automatically sets this property to NO.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么时候应该重写viewDidLayoutSubviews?]]></title>
      <url>%2F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E9%87%8D%E5%86%99viewDidLayoutSubviews.html</url>
      <content type="text"><![CDATA[viewDidLoad重写viewDidLoad是为了配置任何你没有在XIB或者Storyboard中配置的东西。当View controller的视图层从XIB或Storyboard被加载到内存中的时候，viewDidLoad也会被调用。当在loadView方法中代码实现一个view的时候（使用loadVIew的时候，没有必要再使用viewDidLoad）当ViewDidLoad被调用的时候，IBQutlets已经被连接，但是View还没有被加载出来，所以可以在viewDidLoad中完成在IB中不能完成的view的自定义。 注意：当viewController在navigation堆栈中，从此界面跳转到其他界面，再返回过来，不会再走ViewDidLoad方法，所以不能把需要在viewController准备变为活跃状态的时候做相应更新的代码放在这里。 viewWillAppear这个方法用来告诉view controller准备把View展示在屏幕上。重写此方法以执行与应用程序的状态有关的设置以及将要展示在view中的数据。实例： 用于controller使用的数据值 UI定制，例如自定义依赖于数据的颜色或文字 controller的状态等 viewDidLayoutSubviews这个方法在controller的的子视图的position和size被改变的时候被调用。在view 已经被设计好了它的subviews并且还没有被展示在屏幕上时候，可以调用此方法改变这个view。关键点是改变边界。任何依赖于bounds，并且需要去完成的操作都应该放在viewDidLayoutSubviews中，而不是viewDidLoad或viewWillAppear中。因为view的frame和bounds直到Auto Layout 已经完成工作的时候才会被确定，所以在执行完Auto Layout之后会调用此方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的2015]]></title>
      <url>%2F%E6%88%91%E7%9A%842015.html</url>
      <content type="text"><![CDATA[2015年快要告一段落，这一年平稳中又有进步，很知足。 居住环境2014年十一月份申请了锦程之星的优租房，今年四月份终于排到我，搬到了三室两厅的公寓里，拥有单独的卧室，各项设施比较齐全，环境更加安静舒适，不像以前合租时那样和其他人住一个卧室，没有隐私和学习空间。搬到公租房以后，我有了更多的时间做一些有趣的有意义的事情。 可惜有时候我和室友比较懒，而且另一个室友还养了一只垂耳兔整天锁在家里，导致屋里面有时会有一股怪味，屋里不够整洁。自己的房间刚开始每周都会打扫一遍，后来懒了，等到实在看不下去了才打扫。 旅游上半年办了个一百多的吴中旅游年卡，可以免费游玩太湖二十八个旅游景点。五一放假跟同学一起去了西山、石公山和明月湾古村，品尝了鲜美的太湖白鱼，也泛舟太湖之上欣赏迤逦俊美的风光。五月中旬去上海找大学同学玩，逛了逛城隍庙和外滩，没去几个景点，主要是老同学在一起嘛，开心就好了。五月底公司组织去浙江湖州市安吉县旅游，照了很多照片，当时回来以后也都整理了。六月份去了周庄，人比较多，商业化气息太重，不喜欢。较之这几个地方，最喜欢的是西山那边的风景，那里适合安安静静地思考人生，哈哈。 上半年在工作上其实没有怎么上心的，心思都花在玩上面了，几乎每周都计划出去一次。遗憾的是，没有对每次的旅游写一篇游记记录下来。2016年，有意思的旅行要整理和记录，这样的话，以后翻看这些照片和旅行故事，也算是一种美好的人生体验。 健康今年身体还不错，没有怎么感冒发烧啊什么的。只是，在公司里一坐就坐很久，肩膀和背部有时感觉很硬，断断续续坚持按照Keep里面的训练计划做健身，受尚尚影响，开始晚上做仰卧起坐，第一天是做了20个，之后每次比上一次多做一个。 为了跑步，我买了肩带、腰带，还把给我弟的华为手环要过来了，可惜啊，没有坚持下去。也就夏天的时候跑了段时间，后来就改为室内运动了。。。 跑步的作用还是极大的，2016年，把跑步纳入健身大计划中。 感情年中对我来说最重要的事情，是我与尚先生又走在了一起。对于这段故事，此处省略一万字。。。。。。。只想说：我们要相互包容，相互鼓励，奔着共同的幸福生活努力奋斗。 读书七月份之后，把精力重点放在了看书学习、工作和自我管理上。七月十三号那天还专门画了一个图，计划了下半年要看的书（就是下面这个）。到目前为之呢，明显没有完成这个计划。总结一下看书情况： 当代文学：除了《一个人住的好时光》更有实用价值以外，其余基本实在有凑字数之嫌。也有可能是我已经过了那个文青的年纪，是在看不下去这种东西。《一个人住的好时光》的作者是一个日本女人，她从理财、租房、饮食和房间置物归纳等方面，介绍独居女生要注意的地方。举个栗子：书里面介绍了如何快速叠衣服，有哪些简单快捷的一人餐，都是很实用的技巧。村上春树《但我谈跑步时我谈些什么》看了一部分，没有继续读下去。 文学经典：读了《追风筝的人》，两本诗集读了一点之后，感觉语言太干涩，体会不到其中的美，就没有兴趣读下去。《生活的艺术家》是李小龙的著作，读了一半，现在也还在读。 互联网：《从0到1：开启商业与未来的秘密》看了一部分。 个人管理：《做灵魂有香气的女人》好像读完了，之前借给陈桂芳看了几天，现在没有什么印象，也没有做读书笔记，这本书和《人性的弱点》一样，都是卡耐基写的。鸡汤类书籍不用读太多，一两本就ok了。《思维导图使用手册》看了一部分，没有看完。我在培养自己用思维导图分析问题的能力，这本书必看。 专业类：将《Objective-C基础教程》又看了一遍；《iOS开发进阶》感觉不值得买，都是从网上可以找到的内容，并且还都是介绍工具的，不值得不值得啊。。。 理财：本来看完了一本漫画版的《小狗钱钱》，但是发现是精简版的，于是又从网上download了一本完整的，但是还没有看。 总的来说，今年读书情况比较糟糕。时间不够不是理由，有时间看电影、逛街、玩手机，就没有时间看书吗？？？下一年要静下心来好好读几本好书，并且每读完一本都要做一个读书笔记。不能只列计划而不执行。 兴趣爱好 水彩画：从小就喜欢画画，可是，好像越长大对画画的兴致越不高了，本来提起画笔想要认认真真画一幅画，结果还没画完底稿，就坚持不下去了。说到底，是心不静啊。今年买了一本水彩教程，因为有段时间特别想学水彩画，可惜才画了寥寥三幅而已，不过，从第一幅到第三幅的进步还是明显的。 摄影：对摄影的喜爱，不知道从什么时候算起，也许是高中吧，那时候拿着亲戚给的破手机，像素特别低，跟弟弟一起跑到家附近的一个大学里拍荷塘，也是饶有兴致。上大学以后，刚开始也是一直拿手机拍拍，后来男朋友看我实在喜欢拍照，就给我买了个卡片机，好像是索尼的，红色外壳，型号我记不住了。后来把『小红』给家里用了，在大四快毕业的时候，在淘宝上买了微单，出去玩的时候会拿来拍拍，不过后来换了iPhone6之后，用的越来越少了，哈哈。 工作与学习年中把Objective基础又回顾了一遍，并且写了一系列学习笔记，这些笔记在CSDN上开了一个专栏，也保存在了印象笔记中。 学了一段时间的Swift，没有学完。 平时用印象笔记剪藏了一些笔记，也对我起了很多作用。 九月份自己学着用Hexo搭建了个人博客。 从十月份开始在拉勾网上投递简历，经历了好几家公司的电话面试，在准备的过程中又巩固了知识。最后顺利拿到阿里的offer。 这就是我的2015年，希望2016年走得更加坚定而潇洒！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新闻App优化：数据缓存]]></title>
      <url>%2F%E6%96%B0%E9%97%BBApp%E4%BC%98%E5%8C%96%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98.html</url>
      <content type="text"><![CDATA[原因应用需要离线工作的主要原因是：改善应用所表现出来的性能。将应用的内容缓存起来就可以支持离线。 思路：创建一个AppCache单例类创建一个单例类AppCache，用来管理缓存（包括内存缓存和磁盘缓存）。 缓存目录的创建： 在library/caches目录下，创建一个名为『MyAppCaches』的目录，在这个目录下，针对不同的用户，需要创建对应的缓存目录，目录名为用户的ID。比如，用户ID为12345，那么该用户的缓存目录为library/caches/MyAppCaches/12345。这样，在不同的用户目录下，就可以实现个性化的内容缓存。 首页列表缓存目录： 创建首页列表缓存目录：library/caches/MyAppCaches/用户ID/HomeCaches首页有多个不同的栏目，针对不同的栏目，创建不同的缓存目录，比如栏目『热门』的缓存目录为： library/caches/MyAppCaches/用户ID/HomeCaches/热门 新闻详情的缓存目录 新闻详情页的缓存，统一保存在与首页列表缓存目录并列的详情页缓存目录中，如：library/caches/MyAppCaches/用户ID/NewsDetailCaches 实现首页列表数据的磁盘缓存（以『推荐新闻』列表为例，其他栏目是一样的） 为新闻数据创建数据模型类，如NewsModel类，这个类需要遵循NSCoding协议，只有遵循了NSCoding协议，才能使用NSKeyedArchiver对数据模型实例进行归档和反归档。 在NewsModel类中，实现NSCoding协议方法： (id)initWithCoder:(NSCoder *)aDecoder (void)encodeWithCoder:(NSCoder *)aCoder 使用NSKeyedArchiver/NSKeyedUnarchiver对数据模型进行归档和反归档 归档：[NSKeyedArchiver archiveRootObject:objectForArchiving toFile:archiveFilePath]; 反归档：[NSKeyedArchiver archivedDataWithRootObject:objectForArchiving]; 内存缓存（速度更快）创建内存缓存 NSMutableDictionary类型的变量 cachedDirectory :保存缓存的数据 NSMutableArray类型的变量 recentData：保存最近访问的数据 一个整数maxNumber：限制最大内存缓存大小 保存到内存缓存 判断recentData数组中有没有这条数据 如果有相同数据，则删除这条数据，把数据插入到recentData的第一个位置 如果没有，直接插入到最后一个位置 超过保存上限的处理机制当最近访问数据即recentData的count达到上限值maxNumber时，根据LRU（Least Recently Used，最近最少使用）算法做以下处理： 从recentData中删除最后一个数据 从cachedDirectory中删除这个数据 将数据保存到磁盘中 读取内存缓存 根据fileName（新闻ID ）查询 cachedDirectory中是否有数据 如果有，就返回cachedDirectory中的这条数据 如果没有内存缓存数据，则从磁盘中读取（根据filename（新闻ID）和cachePath 路径） 添加对内存警告的处理机制 在AppCache但单例类的静态初始化方法中，注册一个对内存警告通知UIApplicationDidReceiveMemoryWarningNotification的监听器。 在接收到内存警告时，将内存缓存中的数据保存到磁盘中。 添加对App退出和进入后台时的内存管理机制 在AppCache但单例类的静态初始化方法中，注册一个对App进入后台的监听器：UIApplicationDidEnterBackgroundNotification 在AppCache但单例类的静态初始化方法中，注册一个对App退出的监听器：UIApplicationWillTerminateNotification 在接收到上面两个监听器的通知后，将内存缓存中的数据保存到磁盘。 参考资料人民邮电出版社《iOS6编程实战》第二十四章『离线支持』]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作两周年的感悟]]></title>
      <url>%2F%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%91%A8%E5%B9%B4%E7%9A%84%E6%84%9F%E6%82%9F.html</url>
      <content type="text"><![CDATA[突然意识到，今天是十二月二号，前年的今天，也就是2013年12月2日，我入职了现在的公司，一干就是两年。可以说，从事iOS开发，就是从那一天正式开始的。 这两年时间，从毛头丫头走到现在，感悟颇多，把我认为最重要的写下来，算是一个总结吧。 八小时以外做什么在公司，就集中精力在工作上。下班回家后，用简短的时间吃晚饭（其实晚饭可以不吃），休息一下就该活动活动筋骨了。刚开始我用『每日瑜伽』这个App学做瑜伽，后来感觉没劲，就下了另一个健身App『Keep』，一次训练也就二十几分钟，可以多做几个训练。最近每晚加上了仰卧起坐，今天是第八天了，每天比前一天多做一个。 每天运动完洗个澡，看看书。最近在看李小龙《生活的艺术家》。 当然，人都是有惰性的，但我允许自己偶尔懒惰一下，看看电视剧、电影什么的，但是该做的事情还是必须要做的。不然，我对自己没法交代。 极尽可能开拓视野，从海量信息中获取关键数据在公司iMac和自己的Macbook air上使用了翻墙工具鱼摆摆，每个月9 RMB也就是一顿饭的价格，但是回报给我的却是更广阔的知识海洋。同时，我使用了RSS订阅器Inoreader,订阅了一些技术博客。另外，我在Mac上和iPhone上的浏览器里都装了Evernote的插件，零碎时间看到的有价值的文章，就是用这个插件收藏在印象笔记里，周末统一阅读和整理。 在这个信息爆炸的时代，对于如何从海量信息中获取对自己有价值的关键数据，要逐步形成自己的方式方法。浪费时间在垃圾信息上绝对是浪费生命。 远离社交网络，用心做自己的米开朗琪罗社交网络的初衷是好的，一言以蔽之就是方便人们的沟通。我关闭了朋友圈，删除了空间中所有的文字和照片，我不是在说它不好，而是，我想屏蔽没有价值的信息源。 多花点心思在自身与世界的联系上，尝试跳脱出来看自己，雕塑自己，成就自己，保持理性，让心流自然流淌。这样的体验，似乎更有价值。 常立志，立长志世界在变，人也要变。我们在这个科技迅猛发展的时代，学习最新的技术是时间成本最小的做法。人的惰性是天生的，从心理学的角度分析，人对可以让自己变优秀的东西是本能抗拒的，之所以敞开怀抱拥抱新东西，是逻辑分析起了作用。面对新东西，人们会思考它们是否对自己的目标有帮助，如果有，它们就会感兴趣。因此，目标的重要性由此可见。 暂时写到这里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Cheat Sheet [3] - Functions]]></title>
      <url>%2FSwift%20Cheat%20Sheet%20%5B3%5D%20-%20Functions.html</url>
      <content type="text"><![CDATA[无参函数func sayHelloWorld() -&gt; String{ return "hello, world" } print(sayHelloWorld()) 多参函数func sayHello(personName: String) -&gt; String{ return "hello, \(personName)" } func sayHelloAgain(personName: String) -&gt; String{ return "hello again, \(personName)" } func sayHello(personName: String, alreadyGreeted: Bool) -&gt; String { if alreadyGreeted{ return sayHelloAgain(personName) }else{ return sayHello(personName) } } print(sayHello("Sharon", alreadyGreeted: true)) 无返回值函数func sayGoodBye(personName:String){ print("Goodbye, \(personName)") } sayGoodBye("Sharon") 函数的返回值可以被忽略func printAndCount(stringToPrint: String) -&gt; Int { print(stringToPrint) return stringToPrint.characters.count } //函数的返回值可以被忽略 func printWithoutCounting(stringToPrint : String) { printAndCount(stringToPrint) } printAndCount("hello, world") printWithoutCounting("hello, world") 多重返回值函数(使用元组类型）func minMax(array: [Int]) -&gt; (min: Int, max: Int){ var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count]{ if value &lt; currentMin { currentMin = value }else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax) } let bounds = minMax([8, -6, 2, 109, 3, 71]) print("min is \(bounds.min) and max is \(bounds.max)") //prints "min is -6 and max is 109" 可选元组返回类型func minMax2(array: [Int]) -&gt; (min: Int, max: Int)? { if array.isEmpty {return nil} var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] { if value &lt; currentMin { currentMin = value }else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax) } if let bounds = minMax2([8, -6, 2, 109, 3, 71]) { print("min is \(bounds.min) and max is \(bounds.max)") }//prints "min is -6 and max is 109" 指定外部参数名你可以在局部参数名前指定外部参数名，局部参数名和外部参数名之间以空格分隔： func sayHello(to person:String, and anotherPerson:String) -&gt; String{ return ("hello \(person) and \(anotherPerson)") } print(sayHello(to: "Sharon", and: "XiaoYang")) 忽略外部参数名如果你不想为第二个以及后续的参数设置外部参数名，用一个下划线代替一个明确的参数名注意：第一个参数默认忽略其外部参数名称，所以显示地写下划线是多余的 func someFunction(firstParameterName: Int, _ secondParameterName: Int) { // function body goes here // firstParameterName and secondParameterName refer to // the argument values for the first and second parameters } someFunction(1, 2); 默认参数值当默认参数值被定义后，调用这个函数可以忽略这个参数 func someFunction(parameterWithDefault: Int = 12) { // function body goes here // if no arguments are passed to the function call, // value of parameterWithDefault is 12 } someFunction(6)//parameterWithDefault is 6 someFunction()//parameterWithDefault is 12 可变参数在函数类型后面加…来表示可变参数注意：一个函数最多只能有一个可变参数下面的函数用来计算一组任意长度数字的算术平均值 func arithmeticMean(numbers: Double...) -&gt; Double { var total : Double = 0 for number in numbers { total += number } return total / Double(numbers.count) } arithmeticMean(1,2,3,4,5)//prints 3 arithmeticMean(4,5,6,7,8)//prints 6 常量参数和变量参数通过在参数名前加关键字var来定义变量参数： func alignRight(var string : String, totalLength: Int, pad: Character) -&gt; String { let amountToPad = totalLength - string.characters.count if amountToPad &lt; 1 { return string } let padString = String(pad) for _ in 1...amountToPad { string = padString + string } return string } let originalString = "hello" let paddedString = alignRight(originalString, totalLength: 10, pad: "-") //paddedString is eaual to "-----hello" //originalString is still equal to "hello" 输入输出参数(inout关键字)变量参数仅仅能在函数体内被更改。输入输出参数对参数值得修改，在函数体调用完成后依然存在定义一个输入输出参数时，在参数定义前加 inout 关键字。只能传递变量给输入输出参数。输入输出参数不能有默认值，而且可变参数不能用 inout 标记。如果你用 inout 标记一个参数，这个参数不能被 var 或者 let 标记。 func swapTwoInts(inout a: Int, inout _ b: Int) { let temporary = a a = b b = temporary } //调用 var someInt = 3 var anotherInt = 204 swapTwoInts(&amp;someInt, &amp;anotherInt) //Swift 本来就有这个函数： swap(&amp;someInt, &amp;anotherInt) 函数类型的使用函数类型由它的参数类型和返回值类型组成在Swift中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或者变量，并将适当的函数赋值给它 func addTwoInts (someInt : Int, anotherInt: Int) -&gt; Int { return someInt + anotherInt } func multiplyTwoInts (someInt: Int, anotherInt: Int) -&gt; Int { return someInt * anotherInt } var mathFunction1:(Int, Int) -&gt; Int = addTwoInts var mathFunction2:(Int, Int) -&gt; Int = multiplyTwoInts print("Result:\(mathFunction1(2,3))")//prints "Result:5" print("Result:\(mathFunction2(2,3))")//prints "Result:6" 函数类型作为参数类型func printMathResult(mathFunction : (Int, Int) -&gt; Int, _ a: Int, _ b :Int) { print("Result: \(mathFunction(a, b))") } printMathResult(addTwoInts, 2, 3)//prints "Result:5" 函数类型作为返回类型箭头后面写上一个完整的函数类型即可 func stepForward(input: Int) -&gt; Int { return input + 1 } func stepBackward(input: Int) -&gt; Int { return input - 1 } //定义一个函数类型返回值的函数 func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int { return backwards ? stepBackward : stepForward } var currentValue = 3 let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)//计算出从 currentValue 逐渐接近到0是需要向正数走还是向负数走 print("Counting to zero") while currentValue != 0 { print("\(currentValue)...") currentValue = moveNearerToZero(currentValue) } print("zero!") //3... //2... //1... //zero! 嵌套函数将函数定义在别的函数体中。默认情况下，嵌套函数对外界是不可见的，但是，它可以被它的外围函数调用 func chooseStepFunction1(backward: Bool) -&gt; (Int) -&gt; Int { func stepForward(input: Int) -&gt; Int { return input + 1 } func stepBackground(input: Int) -&gt;Int{ return input - 1 } return backward ? stepBackground : stepForward } var currentValue1 = -4 let moveNearerToZero1 = chooseStepFunction1(currentValue &gt; 0) while currentValue1 != 0 { print("\(currentValue1)") currentValue1 = moveNearerToZero1(currentValue1) } print("zero!") // -4... // -3... // -2... // -1... // zero!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是EXC_BAD_ACCESS以及如何调试]]></title>
      <url>%2F%E4%BB%80%E4%B9%88%E6%98%AFEXC_BAD_ACCESS%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95.html</url>
      <content type="text"><![CDATA[某些时候，你可能会遇到由EXC_BAD_ACCESS引起的崩溃。在这片文章中，你将学会什么是EXC_BAD_ACCESS，以及它是由什么引起的。我也将提出一些解决由EXC_BAD_ACCESS引起的bug的技巧。 什么是EXC_BAD_ACCESS？一旦你理解了EXC_BAD_ACCESS的根本原因，你会更好地理解它这个含义模糊的名称。这里有一个简单的解释和一个更加专业的解释。让我们首先以这个简单的解释开始吧。 保持简单无论何时你遇到了EXC_BAD_ACCESS，那就意味着你正在发送一个消息给一个对象，而这个对象已经被释放掉了。这是最常见的情况，但是下面来看看更多的解释。 真正含义专业的解释有一些复杂。在C和Objective-C中，经常处理指针。指针无非是存储另一个变量的内存地址的变量。当你发送一个消息给一个对象，那么指向这个对象的指针需要被引用。这意味着，你取得这个指针指向的内存地址而且访问那块内存的值。 当那块内存不再与你的应用程序映射，或者，换一种说法，那块内存不再以你所期许的方式被使用，那么，就有可能无法访问到那一块内存。当这种情况发生的时候，内核发送异常（ EXC ），表明你的应用程序无法访问到那块内存（BAD ACCESS）。 概括起来就是：当你遇到EXC_BAD_ACCESS时，意味着你在尝试向一块内存发送消息，而这块内存无法执行这个消息。 然而，有时候,EXC_BAD_ACCESS是由一个corrupt pointer（即野指针）引起的。每当你的应用程序程序尝试去引用一个corrupt pointer指针时，内核都会抛出一个异常。 注：corrupt pointer：可以理解为『野指针』。指的是：指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 调试EXC_BAD_ACCESS调试EXC_BAD_ACCESS可能是棘手和令人沮丧的。显示，现在EXC_BAD_ACCESS对你来说不再是那么困难的事情了。 你需要了解的第一件事情是，一旦内存块无法被访问到，你的应用程序就会崩溃。这就是使调试EXC_BAD_ACCESS这么困难的原因。 同样的，当你引用野指针时，情况就糟糕了。 Zombies虽然僵尸在过去的几年中才得到普及，但是，在Xcode中以及出现十多年了。『僵尸』这个名称听起来可能有些戏剧化，但是，这对于解释我们是如何调试EXC_BAD_ACCESS来说，是一个体现其特性的伟大的名字。 在Xcode中，你可以启用僵尸对象（zombie objects），这意味着，被释放的对象作为『僵尸』来被保持。换句话说，被释放的对象为了调试程序而被保持活跃。这没有什么神奇的作用。如果你将消息发送给一个僵尸对象，你的应用程序仍然会得到一个EXC_BAD_ACCESS的崩溃。 为什么启用zombie是有用的？让EXC_BAD_ACCESS难以调试的原因是：你不知道你的应用程序尝试去访问的对象是什么。在多种情况下，僵尸对象能够解决这个问题。通过使被释放的对象保持活跃，Xcode能够告诉你应用程序试图访问的对象，并使问题的检索更加简单。 在Xcode中启用Zombies很简单。注意，你的Xcode版本不同可能导致方法不同。以下方法适用于Xcode 6 和Xcode 7.选择工具条中的Product-&gt; 选择 Scheme -&gt; 选择 Edit Scheme。或者使用快捷方式Command+&lt;。 选择左侧的Run，打开顶部标签中的Diagnotics(诊断)，勾选复选框Enable Zombie Objects。 如果现在遇到EXC_BAD_ACCESS,Xcode控制台的输出会给你一个从哪里开始检索错误的更好的建议。看看下面的例子: 2015-08-12 06:31:55.501 Debug[2371:1379247] -[ChildViewController respondsToSelector:] message sent to deallocated instance 0x17579780 在上面的例子中，Xcode是在告诉我们，这个消息respondsToSelector:被发送给一个僵尸对象。然而，僵尸对象不再是ChildViewController类的一个实例对象。之前分配给ChildViewController实例对象的内存块不再与你的应用程序所映射。这对你认识问题的根本原因有所帮助。 不幸的是，僵尸对象不能解决你所遇到的任何由EXC_BAD_ACCESS所引起的崩溃。如果僵尸对象不能解决你的问题，那么试着去做一些分析。 剖析如果僵尸对象不能帮助你，那么根本原因则是很重要的。这种情况下，你应该仔细看看你的应用程序崩溃时正在执行的代码。这个过程有可能是耗时而麻烦的。 为了帮你找到你的代码中得问题，你可以让Xcode分析你的代码，以帮你找到问题区间。注意，Xcode分析你的项目，可能会指出它遇到的任何一个潜在的问题。 选择Product-&gt;Analyze，或者快捷方式Shift+Command+B，来启用Xcode对你的项目的分析。 这可能消耗Xcode几分钟时间，但是，当它完成的时候，你会在左侧的问题导航器中看到问题清单。通过分析发现的问题以蓝色高亮显示。 当你点击一个问题时，Xcode定位到需要你注意的那块代码。需要注意的是，Xcode只是提出建议，某些时候，有可能问题是不相干的，或者不需要你去解决的。 如果你不能找到引起EXC_BAD_ACCESS的bug，那么仔细检查Xcode在分析过程中找到的问题就很重要了。 结论EXC_BAD_ACCESS是开发人员共同面临的挫折，这是手动内存管理所特有的东西。自推出ARC之后，内存管理相关的问题出现的频率比较低了，但是，它们并没有消失。 本篇文章翻译自：http://code.tutsplus.com/tutorials/what-is-exc_bad_access-and-how-to-debug-it--cms-24544]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅析UITableViewCell重用机制]]></title>
      <url>%2F%E6%B5%85%E6%9E%90UITableViewCell%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6.html</url>
      <content type="text"><![CDATA[UITableView在iOS开发中用的非常的多，由于Cell中一般都会有Image等占用内存的资源，容易引起Memory Warning，所以iOS引入了重用机制。那么今天就对UITableView的重用机制分析一下。 案例分析情况A：所有Cell具有相同的类型-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSInteger times = 0; static NSString *cellIdentifier = @"Default Type"; UITableViewCell *myCell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; if (myCell == nil) { myCell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; NSLog(@"创建%d次",++times); } myCell.textLabel.text= [NSString stringWithFormat:@"第%d行 %@",indexPath.row+1, cellIdentifier]; return myCell; } 分析： 有两个存放Cell的队列：可复用Cell队列 reusableCellQueue 和可见的Cell队列 visualCellQueue； 执行cellForRowAtIndexPath之前，先从reusableCellQueue中寻找标识为Default Style的Cell，如果没有，返回nil，接着会执行initWithStyle：reuseIdentifier； 假设屏幕显示 11行 Cell，如果不滚动TableView，reusableCellQueue是空的，Cell被创建了11次； 向上拖动TableView，使第12行Cell出现在屏幕中（加入到visualCellQueue中），这时，reusableCellQueue仍然是空的。所以又创建了一次Cell； 当第12行Cell完全出现在visualCellQueue中，第1行Cell就加入到了reusableCellQueue中。 再次向上拖动TableView，使第13行Cell出现。注意，这时从reusableCellQueue中寻找到了标识为Default Style的Cell，于是第一行Cell被复用，不用重新创建Cell。 以后再上下滑动，都会在reusableCellQueue中找到可复用的Cell，因此，此TableView完成完整的滚动需要创建 12次 Cell。 总结：第一页显示N行Cell，则一共创建了N+1次。 情况B：具有多种类型的Cell -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { NSString *cellIdentifier; UITableViewCellStyle cellStyle; switch ((indexPath.row + 1)%4) { case 1:{ //有标题和副标题，可选图片 cellIdentifier = @"Subtitle Style"; cellStyle = UITableViewCellStyleSubtitle; } break; case 2:{ //左边文字左对齐，右边文字右对齐，可选的图片 cellIdentifier = @"Value1 Style"; cellStyle = UITableViewCellStyleValue1; } break; case 3:{ //左边文字右对齐，蓝色字体。右边文字左对齐，黑色。没有图片 cellIdentifier = @"Value2 Style"; cellStyle = UITableViewCellStyleValue2; } break; default:{ //有标题，没有副标题，可选的图片 cellIdentifier = @"Default Style"; cellStyle = UITableViewCellStyleDefault; } break; } static NSInteger times = 0; UITableViewCell *myCell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; if (!myCell) { myCell = [[UITableViewCell alloc] initWithStyle:cellStyle reuseIdentifier:cellIdentifier]; NSLog(@"创建%d次",++times); } myCell.textLabel.text = [NSString stringWithFormat:@"第%d行%@",indexPath.row+1, cellIdentifier]; myCell.detailTextLabel.text = @"Subtitle Text"; if (indexPath.row &gt; 3) { myCell.imageView.image = [UIImage imageNamed:@"smile.png"]; } return myCell; } 运行结果是这样的： 分析： 第一页显示11个Cell，创建了11次。 向上拖动TableView，使第12行Cell出现，第12行是Default Style类型的，可复用队列为空，没有找到可复用Cell，于是又创建一次（第12次）。第一个Cell进入reusableCellQueue中。此时reusableCellQueue中只有一个Subtitle Style的Cell。 再次向上拖动，当第13个Cell出现时，从reusableCellQueue中寻找标识为Subtitle Style的Cell，Yes，reusableCellQueue里有这个标识的Cell，于是复用队列里的这个Cell。此时第二个Cell进入reusableCellQueue，队列里有这几个标识：Subtitle Style和Value1 Style。 当第14个Cell出现时，寻找标识为Value1 Style的Cell，也找到了，复用之。此时队列里有Subtitle Style、Value1 Style和Value2 Style 以此类推，以后的Cell都可以在reusableCellQueue中找到可复用的Cell。因此一共创建了12次Cell。 不该有图片的Cell出现了图片当上下滑动TableView的时候，会出现第一行的Cell一会有图片，一会儿又没有图片的现象。这是为什么呢？ 第一个Cell应该是没有图片的，但是在TableView向下滚动，使第一个Cell出现在屏幕上的时候，会先从reusableCellQueue中寻找标识为Subtitle Style的Cell。注意了，第5、9、13、17行的Cell都是Subtitle Style类型的，而且还都带有图片，因此，当这些类型的Cell在reusableCellQueue中被寻找到时，第一行Cell上就会出现图片。 那么，如何解决这类问题呢？ 在配置Cell的时候一定要注意，对取出的重用的cell要重新赋值，不能遗留被重用Cell的数据。 区分两个获取重用Cell的方法- dequeueReusableCellWithIdentifier:forIndexPath:此方法返回一个相关标识的UITableViewCell对象，这个Cell总是有效的(不是nil)。 注意：使用这个方法之前，必须使用registerNib:forCellReuseIdentifier:或者registerClass:forCellReuseIdentifier:注册一个Cell类或者nib。 [tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:cellIdentifier]; UITableViewCell *myCell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier forIndexPath:indexPath]; - dequeueReusableCellWithIdentifier: 返回值 : 相关标识的UITableViewCell对象，或者是nil(如果在可重用Cell队列中没有找到的话)。 UITableViewCell *myCell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; if (myCell == nil) { myCell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; } 比较使用`- dequeueReusableCellWithIdentifier:forIndexPath:`的话，必须注册Cell，而且，不需要再判断Cell是否为nil和创建 Cell。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Cheat Sheet [2] - Control Flow]]></title>
      <url>%2FSwift%20Cheat%20Sheet%20%5B2%5D%20-%20Control%20Flow.html</url>
      <content type="text"><![CDATA[If 条件语句if elselet number = 100 if number &lt; 10 { print("The number is small") } else if number &gt; 100 { print("The number is pretty big") } else { print("The number is between 10 and 100") } if else + for inlet individualScores = [75, 43, 103, 87, 12] var teamScore = 0 for score in individualScores { if score &gt; 50 { teamScore += 3 } else { teamScore += 1 } } print(teamScore) 使用可选绑定var optionalName: String? var greeting = "Hello!" if let name = optionalName { greeting = "Hello, \(name)" }else { print("optionalName is nil") } 在if条件判断语句中使用where关键字var optionalHello: String? = "Hello" if let hello = optionalHello where hello.hasPrefix("H"), let name = optionalName { greeting = "\(hello), \(name)" print("greeting:\(greeting)") }else { //跳到这里，因为hello还没有被复制，它没有“H”前缀，仅当where模式匹配成功，if条件语句才执行。 } Switch一条case分支可匹配多个模式let vegetable = "red pepper" switch vegetable { case "celery": let vegetableComment = "Add some raisins and make ants on a log." case "cucumber", "watercress": let vegetableComment = "That would make a good tea sandwich." case let x where x.hasSuffix("pepper"): let vegetableComment = "Is it a spicy \(x)?" default://必须有default分支 let vegetableComment = "Everything tastes good in soup." } 不存在隐式的贯穿下面的代码会有编译错误！ let anotherCharacter: Character = "a" switch anotherCharacter { case "a": case "A": print("The letter A") default: print("Not the letter A") } // this will report a compile-time error 区间匹配使用闭区间操作符..或开区间操作符..&lt; let approximateCount = 62 let countedThings = "moons orbiting Saturn" var naturalCount: String switch approximateCount { case 0: naturalCount = "no" case 1..&lt;5: naturalCount = "a few" case 5..&lt;12: naturalCount = "several" case 12..&lt;100: naturalCount = "dozens of" case 100..&lt;1000: naturalCount = "hundreds of" default: naturalCount = "many" } print("There are \(naturalCount) \(countedThings).") // 输出 "There are dozens of moons orbiting Saturn." 使用元组let somePoint = (1, 1) switch somePoint { case (0, 0): print("(0, 0) is at the origin") case (_, 0): print("(\(somePoint.0), 0) is on the x-axis") case (0, _): print("(0, \(somePoint.1)) is on the y-axis") case (-2...2, -2...2): print("(\(somePoint.0), \(somePoint.1)) is inside the box") default: print("(\(somePoint.0), \(somePoint.1)) is outside of the box") } // 输出 "(1, 1) is inside the box" 如果存在多个匹配，那么只会执行第一个被匹配到的 case 分支。剩下的能够匹配 case 分支都会被忽视掉. case分支中使用值绑定let anotherPoint = (2, 0) switch anotherPoint { case (let x, 0): print("on the x-axis with an x value of \(x)") case (0, let y): print("on the y-axis with a y value of \(y)") case let (x, y): print("somewhere else at (\(x), \(y))") } // 输出 "on the x-axis with an x value of 2" 使用where 模式匹配let yetAnotherPoint = (1, -1) switch yetAnotherPoint { case let (x, y) where x == y: print("(\(x), \(y)) is on the line x == y") case let (x, y) where x == -y: print("(\(x), \(y)) is on the line x == -y") case let (x, y): print("(\(x), \(y)) is just some arbitrary point") } // 输出 "(1, -1) is on the line x == -y" For循环#使用For-In var firstForLoop = 0 for i in 0..&lt;4 { firstForLoop += i } print(firstForLoop) var secondForLoop = 0 for _ in 0...4 { secondForLoop += 1 } print(secondForLoop) 使用下划线_替代循环变量名如果你不需要知道区间内每一项的值，你可以使用下划线（_）替代变量名来忽略对值的访问：code: let base = 3 let power = 10 var answer = 1 for _ in 1...power { answer *= base } print("\(base) to the power of \(power) is \(answer)") // 输出 "3 to the power of 10 is 59049" code2: var secondForLoop = 0 for _ in 0...4 { secondForLoop += 1 } print(secondForLoop) //输出5 遍历数组元素let names = ["Anna", "Alex", "Brian", "Jack"] for name in names { print("Hello, \(name)!") } // Hello, Anna! // Hello, Alex! // Hello, Brian! // Hello, Jack! 遍历字典的键值对字典元素的遍历顺序和插入顺序可能不同 let numberOfLegs = ["spider": 8, "ant": 6, "cat":4] for (animalName, legCount) in numberOfLegs{ print("\(animalName)s have \(legCount) legs") } // ants have 6 legs // cats have 4 legs // spiders have 8 legs 使用条件判断和递增方法的标准 C 样式for循环for var index = 0; index &lt; 3; ++index { print("index is \(index)") } // index is 0 // index is 1 // index is 2 While循环whilevar count = 1 while count &lt; 3 { println("count is \(count)") ++count } // count is 1 // count is 2 count = 1 while count &lt; 1 { println("count is \(count)") ++count } repeat-whilevar count = 1 repeat { print("count is \(count)") ++count } while count &lt; 3 // count is 1 // count is 2 count = 1 repeat { print("count is \(count)") ++count } while count &lt; 1 // count is 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Cheat Sheet [1] — Basic Types]]></title>
      <url>%2FSwift%20Cheat%20Sheet%20%5B1%5D%20%E2%80%94%20Basic%20Types.html</url>
      <content type="text"><![CDATA[常量和变量Varibalesvar myInt = 1 //inexplicit type var myExplicitInt : Int = 1 // explicit type var x = 1, y = 2, z = 3 //declare multiple integers myExplicitInt = 3 // set to another integer value Constantslet myInt = 1 myInt = 2 //compile-time error !!! 常量和变量的命名let π = 3.14159 let 你好 = "你好世界" let 🐶🐮 = "dogcow" //可以用任何字符作为常量或变量名，包括Unicode字符 可选类型可选类型，暗示常量或者变量可以没有值。 let possibleNumber = "123" let convertedNumber = Int(possibleNumber) // convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int" nil可以给可选变量赋值为nil来表示它没有值. var serverResponseCode: Int? = 404 // serverResponseCode 包含一个可选的 Int 值 404 serverResponseCode = nil // serverResponseCode 现在不包含值 如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为nil var surveyAnswer: String? // surveyAnswer 被自动设置为 nil 注意： Swift 的nil和 Objective-C 中的nil并不一样。在 Objective-C 中，nil是一个指向不存在对象的指针。 在Swift 中，nil不是指针——它是一个确定的值，用来表示值缺失。 任何类型的可选状态都可以被设置为nil，不只是对象类型。 nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。 if 语句以及可选值的强制解析（forced unwrapping）使用if语句和nil比较来判断一个可选值是否包含值当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值 var convertedNumber : Int? = 10 if convertedNumber != nil{ print("convertedNumber has an integer value of \(convertedNumber!)") } // 输出 "convertedNumber has an integer value of 10" 可选绑定（option binding）使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在if和while语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量 一个示例解析 示例： let possibleNumber = “123” if let actualNumber = Int(possibleNumber){ print("\'\(possibleNumber)\' has an integer value of \(actualNumber)") }else{ print("\'\(possibleNumber)\' could not be convered to an integer") } 解释这个示例：如果Int(possibleNumber)返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经被可选类型包含的值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，actualNumber只被用来输出转换结果。 包含多个可选绑定在条件判断语句中if let firstNumber = Int("4"), secondNumber = Int("42") where firstNumber &lt; secondNumber { print("\(firstNumber) &lt; \(secondNumber)") } // prints "4 &lt; 42" 隐式解析可选类型（implicitly unwrapped optionals）在Swift构造的过程中，当可选类型第一次赋值之后，就可以确定之后一直有值。这种情况下，可选类型的可选状态被定义为隐式解析可选类型。把可选类型后边的问号改为叹号。 let possibleString: String? = "An optional string." let forcedString: String = possibleString! // 需要惊叹号来获取值 let assumedString: String! = "An implicitly unwrapped optional string." let implicitString: String = assumedString // 不需要感叹号 分号//Swift不强制要求在语句结尾处使用分号，当然，也可以按照自己的习惯添加 //当在同一行内写多条独立的语句时，必须要用分号！ let cat = "🐱";print(cat) 整数整数范围使用min和max属性获取整数的最小值和最大值 let minValue = UInt8.min // minValue 为 0，是 UInt8 类型 let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型 Int 在32位平台上，Int和Int32长度相同。 在64位平台上，Int和Int64长度相同。 Int足够用了。 UInt 在32位平台上，UInt和UInt32长度相同。 在64位平台上，UInt和UInt64长度相同。 尽量不要使用UInt 浮点数 Double表示64位浮点数，至少15位小数点。当你需要存储很大或者很高精度的浮点数时请使用此类型。 Float表示32位浮点数，至少6位小数点。精度要求不高的话可以使用此类型。 String操作符+var myString = "a" let myImmutableString = "c" myString += "b" // ab myString = myString + myImmutableString //abc myImmutableString += "d" //compile-time error!!! 字符串插值\(value)let count = 7 let message = "There are \(count) days in a week" Bool值在if语句中的应用let turnipsAreDelicious = false if turnipsAreDelicious { print("Mmm, tasty turnips!") }else { print("Eww, turnips are horrible.") } 元组元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。 创建一个元组let http404Error = (404, "Not Found") //let http404Error = (404, "Not Found") 分解元组内容let http404Error = (404, "Not Found") let (statusCode, statusMessage) = http404Error print(("The status code is \(statusCode)")) // 输出 "The status code is 404" print("The status message is \(statusMessage)") // 输出 "The status message is Not Found" 用下划线_忽略一部分元组值如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记： let (justTheStatusCode, _) = http404Error print("The status code is \(justTheStatusCode)") // 输出 "The status code is 404" 访问元组的单个元素print("The status code is \(http404Error.0)") // 输出 "The status code is 404" print("The status message is \(http404Error.1)") // 输出 "The status message is Not Found" 给元组的单个元素命名let http200Status = (statusCode: 200, description: "OK") 通过名字访问元组元素print("The status code is \(http200Status.statusCode)") // 输出 "The status code is 200" print("The status description is \(http200Status.description)") // 输出 "The status message is OK" 类型别名typealias AudioSample = UInt16 //使用typealias关键字来定义类型别名 var maxAmplitudeFound = AudioSample.min //maxAmplitudeFound 现在是 0 类型转换整数和浮点数整数 to 浮点数let three = 3 let pointOneFourOneFiveNine = 0.14159 let pi = Double(three) + pointOneFourOneFiveNine // pi 等于 3.14159，所以被推测为 Double 类型 浮点数 to 整数let integerPi = Int(pi) // integerPi 等于 3，所以被推测为 Int 类型 整数和字符串Int to Stringlet label = "The width is" let width = 94 let widthLabel = label + String(width)// The width is 94 String to Intcode1: var myString = "7" //7 var possibleInt = Int(myString) //7 print(possibleInt) //"Optional(7)\n" code2: var myString1 = "banana" // "banana" var possibleInt1 = Int(myString1) //nil print(possibleInt1) // "nil\n" Printinglet name = "Swift" println("Hello") pringln("My name is \(name)") print("See you") print(later) /* Hello My name is Swift See you later */ Logical Operatorsvar happy = true var sad = !happy//logical NOT,sad = false var everyoneHappy = happy &amp;&amp; sad//logical AND, everyoneHappy = false var someoneHappy = happy || sad //logical OR, someoneHappy = true Functionsfunc iAdd(a:Int,b:Int,c:Int) -&gt; Int{ return a + b + c } iAdd(1, b: 2, c: 3)//return 6 func eitherSide(n:Int)-&gt; (nMinusOne:Int, nPlusOne:Int){ return(n-1, n+1) } eitherSide(5)//(.0 4, .1 6) Array空数组// Creates an empty array. let emptyArray = [String]() // [] 索引var ratingList = ["Poor", "Fine", "Good", "Excellent"] ratingList[1] = "k" ratingList // return ["Poor", "OK", "Good", "Excellent"] 拼接数组var colors = ["red", "blue"] //["red", "blue"] var moreColors: [String] = ["orange", "purple"] //["orange", "purple"] colors.append("green") //["red", "blue", "green"] colors += ["yellow"] //["red", "blue", "green", "yellow"] colors += moreColors //["red", "blue", "green", "yellow", "orange", "purple"] 添加和删除元素var days = ["mon", "thu"] var firstDay = days[0] // mon days.insert("tue", atIndex: 1) // [mon, tue, thu] days[2] = "wed" // [mon, tue, wed] days.removeAtIndex(0) //[tue, wed] Dictionaryvar days = ["mon": "monday", "tue": "tuseday"] days["tue"] = "tuesday" // change the value for key "tue" days["wed"] = "wednesday" // add a new key/value pair var moreDays: Dictionary = ["thu": "thursday", "fri": "friday"] moreDays["thu"] = nil // remove thu from the dictionary moreDays.removeValueForKey("fri") // remove fri from the dictionary]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HScrollViewWithTitleAndSlide]]></title>
      <url>%2FHScrollViewWithTitleAndSlide.html</url>
      <content type="text"><![CDATA[功能说明 模仿LOFTER发现界面的页面切换效果 标题可以随着内容的滚动而滚动 下拉展示所有标题以供点选 下拉按钮的图片和勾选的图片可以自定义，每页最多显示的标题的个数可以自定义。 封装的比较完整，使用起来很简单，几句代码搞定。 使用Xcode7.0.1 Objective-C GitHub地址：https://github.com/SharonHu1990/HScrollViewWithTitleAndSlide 框架使用说明 拖拽HSlideScrollView文件夹到你的工程目录. 在需要使用该框架的ViewController中添加如下代码： 代码示例： /** * 添加MySlideScrollView */ -(void)addMySlideScrollView { CGRect slideScrollFrame = CGRectMake(0, 64, self.view.frame.size.width, self.view.frame.size.height-64); NSArray *titlesArray = [[NSArray alloc] initWithObjects:@"A", @"B", @"C", @"D", @"E", @"F", @"G", @"H", @"I", @"J", @"K", @"L", @"M", @"N", nil]; mySlideScrollView = [[HSlideScrollView alloc] initWithFrame:slideScrollFrame andTitleArrays:titlesArray andTitleScrollerViewHight:40.f andNumverOfTitlesPerPage:7 andArrowImage:[UIImage imageNamed:@"arrow_down"] andTickImage:[UIImage imageNamed:@"tick"] andTitleListTitle:@"分类"]; [self.view addSubview:mySlideScrollView]; } 功能演示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发总结]]></title>
      <url>%2FiOS%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[记录iOS开发过程中使用的技术、遇到的问题以及解决方法。 自定义系统键盘上方的View有两种方法1.设定textfield或者textview的inputAccessoryView属性2.监听键盘事件，获取键盘高度，动态改变自定义View的位置 CocoaPods 执行 pod update 和 pod install 卡住不动使用加参数的命令：pod install –verbose –no-repo-update或者pod update –verbose –no-repo-update 添加PCH文件注意在BuildSetting中设置Prefix header路径 添加讯飞语音需要的系统类库 安装CocoaPods错误如果是下面这个错误：Could not find a valid gem ‘cocoapods’ (&gt;= 0), here is why: Unable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Op… 解决方法，看这里! Undefined symbols for architecture arm64 检查Pod的TARGETS和工程项目的TARGETS的BuildSetting 检查工程项目TARGETS的Other Linder Flags 理解armv7 armv7s arm64 i386 x86_64看这篇博文 什么时候用Block或代理？看这篇博文1.要是一个对象有超过一个的不同的事件，使用代理2.要是一个对象是个单例，我们不能使用代理3.要是一个对象调用方法需要返回一些额外的信息，我们可能需要使用代理4.过程 vs. 结果5.速度（也许吧？） 具体情况，具体分析! 使用%运算符出现错误：invalid operands to binary expression (‘CGFloat’(aka ‘double’) and ‘CGFloat’)CGFloat c = a % b;解决：% is for int or long, not float or double.You can use fmod() or fmodf() from instead.Better is as suggested by the inventor of CGFloat. Objective-C浮点数向上取整和向下取整：向上取整：ceil（f）//f为浮点数向下取整：floor(f)//f为浮点数 TableView的分割线从顶端开始：if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) { [self.tableView setLayoutMargins:UIEdgeInsetsZero]; } if ([cell respondsToSelector:@selector(setSeparatorInset:)]) { [cell setSeparatorInset:UIEdgeInsetsZero]; } if ([cell respondsToSelector:@selector(setLayoutMargins:)]) { [cell setLayoutMargins:UIEdgeInsetsZero]; } Swift中宏替换与代码标识看这里 监听输入框内容的改变[textField addTarget:self action:@selector(textFieldValueChanged:) forControlEvents:UIControlEventEditingChanged]; [button setTitleColor:[UIColor redColor] forState:UIControlStateSelected]不起作用因为设置了button的AttributedTitle，所以在[button setSelected:YES];之前，先设AttributedTitle为nil如下：[button setAttributedTitle:nil forState:UIControlStateNormal]; 保存图片到相册/** * 保存图片 */ - (void)saveImage{ /** * 将图片保存到iPhone本地相册 * UIImage *image 图片对象 * id completionTarget 响应方法对象 * SEL completionSelector 方法 * void *contextInfo */ UIImageWriteToSavedPhotosAlbum(_allImagesOfThisArticle[currentPhotoIndex], self, @selector(image:didFinishSavingWithError:contextInfo:), nil); } - (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo: (void *)contextInfo { if (!error) { //it worked do the thing } } Request failed: unacceptable content-type: text/html using AFNetworking 2.0解决方法是添加：manager.responseSerializer.acceptableContentTypes = [manager.responseSerializer.acceptableContentTypes setByAddingObject:@”text/html”]; Xcode打开代码聚焦栏(Focus Ribbon)的方式 Xcode查找快捷方式（以code folding为例） 区分StoryBoard中的Show、Show Detail、Present Modally、Popover Presentation、Custom Show 将目标试图控制器push到navigation堆栈中，由右至左地显示试图控制器，提供一个后退按钮在navigation bar 上。 例如：应用Mail中导航到收件箱 Show Detail 在UISplitViewController中，替换详情视图或次级视图，不提供返回按钮。 例如：iPad上的邮箱应用在横屏时，点击左侧侧边栏的邮件列表，右侧显示邮件的详情。 Present Modally 通过定义不同的Presendation option，以不同的方式展示视图控制器，覆盖上一个视图控制器。最常用的呈现动画是从屏幕底部出现视图控制器，覆盖整个屏幕。但是，在iPad上，最常见的呈现方式是将视图控制器呈现在屏幕的正中间，并且将底部的视图控制器变暗，从下向上出现。 例如：点击iPhone上日历应用的”+”按钮。 Popover（iOS8之后改为：Present as Popover） 当在iPad中运行时，目标视图展示在一个小popover视图中，点击popover视图之外的其他任何地方，视图将消失。iPhone也支持popover，但是，如果连接一个Popover Presentation segue,将会与执行Present Modally的效果相同。 例如：在iPad上的日历应用中点击+按钮。 Custom 你可能会实现和控制自定义的视图切换方式。 这些视图切换类型在iOS8中被弃用：Push、Modal、Popover、Replace。 看这里，了解更多。 关于M_PI#define M_PI 3.14159265358979323846264338327950288 其实它就是圆周率的值，在这里代表弧度，相当于角度制 0-360 度，M_PI=180度旋转方向为：顺时针旋转 sender.transform = CGAffineTransformRotate(sender.transform, -M_PI_2*1.0); sender.transform = CGAffineTransformRotate(sender.transform, -M_PI_2*1.0); 判断ScrollView向左滑还是向右滑？-(void)scrollViewDidScroll:(UIScrollView *)scrollView { contentScrollViewCurrentPosition = scrollView.contentOffset; if (contentScrollViewCurrentPosition.x &lt; contentScrollViewStartPosition.x &amp;&amp; contentScrollViewCurrentPosition.x &lt; myContentScrollView.contentSize.width) { scrollDirection = DirectionLeft; }else if(contentScrollViewCurrentPosition.x &gt; contentScrollViewStartPosition.x &amp;&amp; contentScrollViewCurrentPosition.x &gt; 0){ scrollDirection = DirectionRight; } } // 当开始滚动视图时，执行该方法。一次有效滑动（开始滑动，滑动一小段距离，只要手指不松开，只算一次滑动），只执行一次。 - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{ contentScrollViewStartPosition = scrollView.contentOffset; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观《被嫌弃的松子的一生》有感]]></title>
      <url>%2F%E8%A7%82%E3%80%8A%E8%A2%AB%E5%AB%8C%E5%BC%83%E7%9A%84%E6%9D%BE%E5%AD%90%E7%9A%84%E4%B8%80%E7%94%9F%E3%80%8B%E6%9C%89%E6%84%9F.html</url>
      <content type="text"><![CDATA[电影讲述了一位日本女性悲哀的、充满遗憾的一生。 青年松子是一名中学的班主任，一次年级旅行中，她用一个并不恰当的方式，解决学生的偷窃事件，却惹祸上身，被学校辞退，这意外地改变了她从此以后的人生轨迹。不，不能说是意外。从小到大，松子的父亲都对得了肺炎的妹妹久美格外疼爱，却无意中忽略了对松子的关怀。松子为了让父亲多注意她，学着舞台剧里小丑的模样拌鬼脸惹父亲发笑。当她把自己恋爱的消息说给妹妹听后，父亲当着全家人的面呵斥她，认为她没有考虑因生病而无法出门的妹妹的感受。从小到大所受到的所有委屈，就在这一次的家庭教育中喷薄而发，一起之下，松子离家出走。 离家出走后的松子所经历的一切，包括不堪的工作经历以及屡屡在感情中遭受被抛弃的命运，我觉得，本质上是她从小因特殊的家庭环境而形成的性格有关。小时候，为了取悦父亲而扮鬼脸；作为一名教师，为了委婉地解决学生的偷窃事件，却自己偷钱还给旅馆老板；当自己的作家男友自杀后，居然因为男友对手特殊的关爱，情愿做起了人家的情人，做着取代正宫的美梦；最后和做了为小混混学生谈了一场轰轰烈烈的恋爱，因为男友是混混，她要做混混女；在最后这场感情也无疾而终之后，她选择放弃一切，不走近任何人，也不让任何人走进她的世界，如此自甘堕落下去……她从未想过，要为自己如何在这世上过活，却一味地追求只要有人陪伴就好。可能在被她爱得人看来，她做的一切是出去热爱和包容，可是，这些所谓的对别人的好，恰恰是对自己极大的不负责任。一味地依赖别人，不思考自己的人生意义的人，最后的苦果只有自己去吃。 性格决定命运，这也是看完该片之后的感受。父母对自己所有的孩子都要公平看待，不要因为自己的过错，对孩子性格的形成造成不良影响。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用网络代理造成Archive submission failed with errors]]></title>
      <url>%2F%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E9%80%A0%E6%88%90Archive%20submission%20failed%20with%20errors.html</url>
      <content type="text"><![CDATA[提交archive到AppStore，出现这个错误： 从中可以看出是网络原因导致的，我使用了鱼摆摆网络代理，所以有可能是因为使用了鱼摆摆。 那么如何解决呢？ 首先，打开鱼摆摆的设置，点击“高级”，查看是否勾选了代理所有网站，如果勾选了，取消掉。 然后，取消启用系统代理（不选第一行的“启用系统代理”）。 做完上述的设置后，重新提交archive，成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以此纪念2015年最后一个长假的结束]]></title>
      <url>%2F%E4%BB%A5%E6%AD%A4%E7%BA%AA%E5%BF%B52015%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E9%95%BF%E5%81%87%E7%9A%84%E7%BB%93%E6%9D%9F.html</url>
      <content type="text"><![CDATA[2015年的最后一个长假终于还是结束了。这个旷日持久的假期横跨中秋和国庆，从9月24日持续到10月7日，总共十四天之久。为了拼这个假期，请了2.5天的年假和2.5天的事假。至于为什么是2.5天年假，而不是5天，那是因为今年休的是2014年的年假，而我是2014年7月份才开始转正的。不过想想春节的时候还是可以休5天年假，以此来拼凑十二天的长假，还是无比欣慰：）。 每个假期都好像是一个空白的画布，放假之前总会在脑海中构思着画一幅多么精彩的图画，图画上有绚丽的色彩和动人的故事情节；而假期刚刚开始，仿佛有一种莫名的力量，总会阻碍你按照预期的想法绘画，于是乎，画布上布满了随心所欲的涂鸦。假期过后，再去看这副假期涂鸦作品，竟然也被它明快的色彩和稍有遗憾的情节所感动。 这个假期，在家里过了二十五岁生日，过了中秋节，当然还有国庆节。爸妈还是放任我每天睡到自然醒，当然，如果当天有什么出门的安排的话，还是会叫叫我的。在家里不出去的话，也就是一家人吃吃饭，看看电视，和老妈一起睡午觉，如果午觉我睡着了，那肯定是一觉睡到了下午五六点，癔症一会儿又该吃完饭了：）。跟弟弟在家里在网上看了《大圣归来》，但我有点看不下去，实在觉得国产动画给人提不上劲的感觉：情节拖沓、动画不华丽，好在他放假后我们在奥斯卡影城看的《小黄人大眼萌》很精彩，其实本来要看《夏洛特烦恼》的，可以那天的场次时间不满意。本打算全家一起出去游玩，爸爸提出的建议有丹江口水库、鸭河水库、社旗山陕会馆，可惜因为种种琐事，最终没有成行。遗憾是有一些的，不过平平淡淡的生活才是最幸福的。 回家后把《追风筝的人》这本书剩下的内容看完了。“为你，千千万万遍”是哈桑对阿米尔说过得话，也是阿米尔在找到哈桑的儿子后对他说过的话，出现过三次，三次出现的含义不同：为了你我可以追千千万万遍的风筝；也可以为你做所有的事情千千万万遍；可以千千万万遍的保护你，没有终止的那天。这么一个简单的句子，蕴含着绵延不尽的深情。本想写一篇读后感，可惜文笔不佳。豆瓣读书上这篇文章写的不错，其中的一些感悟是我深有体会却无法极力描述的。另外，这本书也被拍成了电影，豆瓣评分8.2，找个时间看看。 原文如下： 大凡是有深刻情感经历的人，对这句话都会有一定的敏感度。因为这句话里蕴涵着说者对听者饱满而充溢得几乎止不住外泄的深情。当我们一字一顿地默念这七个字时，“为、你、千、千、万、万、遍”，便仿佛身边所有的喧哗和嘈杂都在瞬间飞弛而去，它们乘上呼啸的列车，在生命的布景墙上渐渐淡开，没有愤懑、抱怨，也没有偏见、猜测、评判。我们所看见的，就是七朵静静的野蔷薇。 你可以想象这是一段铭心刻骨的恋情，一方为着另一方千万次地奔波、努力、思念；也可以想象这是一种无法割舍的亲情，疲惫地伫立在火车站台上等候的母亲，千万次地祈祷、盼望、付出；当然，你还可以想象成一段生命里的友谊和默契……但这个故事却超离了这所有的想象之外，它很离奇地诉说着一个原本为兄弟血缘却在充满战火、信仰危机、种族争端的中东背景之下被人为隐瞒成主仆关系的两个不知情的孩子以及它们长大后的故事。这个故事情节跌荡起伏，然而，当我看到地位卑微而备受凌辱的哈桑执著地对阿米尔说出这七个字时，我确实忘却了弥漫在整部小说里的背叛、欺骗和救赎，于是，在我合上这本书以后，脑海里留下的是一片响着清脆笑声的小树林，它离这个世界很远。 我以为，再黑暗的人性里总会有一道烛光。而正是这道烛光，就足以点亮灰冥无火的世界。这样看来，再悲剧的人物情节也会有过温暖的笑脸。 我们往往被迫诞生在一场既定的牌局里，在这场牌局之内，有固定的生活经历和人际关系网，这是幼稚的孩童无法认知和篡改的。因为他们清澈的双眼不认得声誉、金钱作祟的闹剧，也同样不认得人情的冷漠和悲凉。在责任的推脱下，每个人都活在不同的牌理之中。所以孩子是该得到原谅的，因为你完全不忍心鞭笞一个当时内心只是单纯地不理解甚至是憎恨父亲对仆人哈桑情感上的倾斜，只是想通过风筝大赛而获得十足的父爱而背叛哈桑的缺爱的富家小少爷阿米尔。孩子不会故意犯错，孩子的错都是大人的错。 于是哈桑说：“为你，千千万万遍。”他的忠实和真诚就这样随着简单的语气荡漾开来……我想，罪赎和原谅确是很好地均衡了这个世界。三毛在《这种家庭生活》里写过一句话我到现在还记忆尤深：“爱是恒久忍耐而又有恩慈。”恒久，在时间的外衣下坚守着感情的从一而终；忍耐，弱化自身的个性尊严以学会包容；恩慈，普度陷入崖底的人心。在毫无文化水平的哈桑的内心中，贮存着的善良和怜悯之心会令很多人质疑学术争吵的意义。这样，再强势的文化也会在孩子的目光前低下高傲的头颅，因为那是人类原始的皈依和追述。 为你，只为你。 千千万万遍，哪怕千千万万遍。 如果是你，你敢不敢说，又敢不敢用尽全力地说。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[纪·彩虹蛋糕]]></title>
      <url>%2F%E7%BA%AA%C2%B7%E5%BD%A9%E8%99%B9%E8%9B%8B%E7%B3%95.html</url>
      <content type="text"><![CDATA[蛋糕先生昨天起了个大早，赶早班车来苏州。他提前在网上订了蛋糕，中午十二点之前送到。因为单位周日开会，他只能陪我短暂的几个小时，这是见到他之后他才说的，不然怎么都不会让他来的。蛋糕打开的一瞬间，我像个小孩子一样兴奋得差点跳了起来，是彩虹蛋糕，五彩缤纷，很可爱！我在一旁又是小心舔舐着奶油，又是拿着手机拍照，他则羞涩地说比想象中的小了。很感动，但是更多是心疼，这么折腾地来回跑着，就为了在我放假回家去提前一起过个生日。 认识这么多年了，还是第一次一起吃生日蛋糕。特别是他开始为我切蛋糕的时刻，瞬间觉得外面的世界再怎么纷乱，有这么一个人，惦念着你，和你一起分享幸福，这就够了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bundle version VS Bundle versions string]]></title>
      <url>%2FBundle%20version%20VS%20Bundle%20versions%20string.html</url>
      <content type="text"><![CDATA[今天上传新版本，在修改Bundle version和Bundle versions string的时候突然想到：一直以来都没有深究过这两个字段的真正含义，只是保持它们一样。那么它们真正的用途到底是什么呢？今天来探究一下。 区别Bundle Version (CFBundleVersion) Bundle Version是应用程序的内部版本号。 Bundle Version不需要是一个纯粹的版本号，它可以是1234，也可以是1.2.3(Build 12345AB) Bundle Version String (CFBundleShortVersionString) Bundle versions string 是应用程序公开可见的版本号。例如，你每次迭代一个内部测试版本时，都会生成一个版本号，这个版本号可能是2.0.0.12345b7，但是你不想让其公开可见，所以你设置应用程序的短版本号为2.0。 必须与用于iTunes Connect的版本号保持一致。 Bundle Version String不能超过三个部分。例如：2.0.1是可以的，但是2.0.0.1是不可以的。 当Bundle Version String缺省时，Bundle Version替代Bundle Version String的功能，同时也继承他的限制(比如格式，位数等)，展示在AppStore中。 Xcode 设置自增编译版本号步骤： Info.plist 中设置Bundle Version String； Info.plist中Bundle version设置为数字 比如1，如果设置为其它，则可能会编译错误； 添加脚本 TARGETS -&gt; Build Phases 点击左上角的‘+’，在弹出的选择框中点击New Run Script Phase，如下图： 在Run script中添加以下脚本： version=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" $PRODUCT_SETTINGS_PATH` version=`expr $version + 1` /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $version" $PRODUCT_SETTINGS_PATH #/usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $version" $PRODUCT_SETTINGS_PATH 这行代码会让version也自增，一般不需要 如图： OK,这样设置以后，每次编译，Build version都会自增1.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown为写作而生]]></title>
      <url>%2FMarkdown%E4%B8%BA%E5%86%99%E4%BD%9C%E8%80%8C%E7%94%9F.html</url>
      <content type="text"><![CDATA[学习Markdown知识，纵享写作之乐！ 写作有什么难题？Markdown是如何解决的？.doc 或 Pages 格式有如下问题： 不一定谁都能打开。用 Windows 的人打不开 .pages 文件，用旧版 Word 的人不一定能打开你用新版 Word 写的稿子。 对方看到的稿子的样子和你自己看到的可能差别很大。 Office 已经是你电脑上唯一的盗版软件，导致心情不佳。 使用Markdown有如下好处： 兼顾了「什么人都能打开」和「样式」 Markdown 就是纯文本，就是 txt，所以什么人都能打开。而如上所述，你可以用它来标记文本的样式，而且语法非常简单。 由于是纯文本，Markdown 文稿也不会因为未来软件升级而产生不同版本之间的兼容问题，即，不会出现「我这篇稿子是用旧版 Word 写的，你用新版 Word 看可能格式会有点问题」的情况。 Markdown 转 HTML 非常方便，对未来有益处 HTML 是整个万维网（web）的标记语言，但更重要的是，它也是目前主流电子书格式所用的标记语言。无论是 EPUB, mobi，还是 Kindle 用的专有格式 .azw，都只是把一堆 HTML 文件打包而已。如果你写的是书，用 Markdown 标注格式之后，可以很方便地转为以上格式（当然这个转换工作不需要由你来做）；如果你写的是单篇的文章（例如新闻报道或专栏），未来也不排除结集出书的可能。若采用 Markdown，对于日后的文件转换工作也大有裨益。 Markdown的使用群文艺青年 為什麼文科生也該用markdown寫作 为什么作家应该用 Markdown 保存自己的文稿 科学青年 如何学习科学：开放科学工具箱 Markdown基本语法段落段落的前后要有一个以上的空行。（空行的定义是显示上看起来像是空行，就被视为空行。例如一行中只有空白和Tab，那么该行也被视为空行），普通的段落不需要用空白或制表符来缩进。 标题Markdown 支持两种标题的语法: Setext:用底线的形式，利用 = （最高阶标题）和 - （第二阶标题） atx:行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶 Setext: 标题一 ======= 标题二 ------ atx： # 标题一 ## 标题二 ### 标题三 #### 标题四 ##### 标题五 ###### 标题六 区块引用区块引用则使用 email 形式的 ‘&gt;’ 角括号 &gt;这是一个区块引用 &gt; &gt;这是区块引用的第二段 &gt; &gt;## 这是一个区块引用中的二级标题 显示效果为： 这是一个区块引用 这是区块引用的第二段 这是一个区块引用中的二级标题 输出HTML： &lt;h1&gt;A first Leavel Header&lt;/h1&gt; &lt;h2&gt;A Second Leavel Header&lt;/h2&gt; &lt;p&gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.&lt;/p&gt; &lt;p&gt;The quick brown fox jumped over the lazy dog's back.&lt;/p&gt; &lt;h3&gt;Header 3&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;This is a blockquote.&lt;/p&gt; &lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt; &lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt; &lt;/blockquote&gt; 修辞和强调Markdown 使用星号和底线来标记需要强调的区段。示例： *文字两边各添加一个星号表示斜体字* _文字两边各添加一个短下划线表示斜体字_ **文字两边各添加两个星号表示粗体字** __文字两边各添加两个短下划线表示粗体字__ 显示效果为：文字两边各添加一个星号表示斜体字文字两边各添加一个短下划线表示斜体字 文字两边各添加两个星号表示粗体字文字两边各添加两个短下划线表示粗体字 输出HTML为： &lt;em&gt;斜体字 &lt;/em&gt; &lt;strong&gt;粗体字&lt;/strong&gt; 无序列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的。任何数量的 * 、= 和 - 都可以有效果。 使用星号：星号前面再添加一个空格则生成一个二级列表。 * Item1 * Item2 * 1 * 2 * 3 * Item3 使用加号： + Item1 + Item2 + 1 + 2 + 3 + Item3 使用减号： - Item1 - Item2 - 1 - 2 - 3 - Item3 以上的显示效果都是这样的： Item1 Item2 1 2 3 Item3 以上都会输出HTML为： &lt;ul&gt; &lt;li&gt;Item1&lt;/li&gt; &lt;li&gt;Item2&lt;/li&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;Item3&lt;/li&gt; &lt;/ul&gt; 有序列表有序的列表则是使用一般的数字接着一个英文句点,后跟一个空格，作为项目标记 1. Item1 2. Item2 1. Red 2. Yellow 3. Blue 3. Item3 显示效果为： Item1 Item2 Red Yellow Blue Item3 输出的HTML为： &lt;ol&gt; &lt;li&gt;Item1&lt;/li&gt; &lt;li&gt;Item2&lt;/li&gt; &lt;ol&gt; &lt;li&gt;Red&lt;/li&gt; &lt;li&gt;Yellow&lt;/li&gt; &lt;li&gt;Blue&lt;/li&gt; &lt;/ol&gt; &lt;li&gt;Item3&lt;/li&gt; &lt;/ol&gt; 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt;和&lt;code&gt;标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落 这是一个代码区块 Markdown 会转换成： &lt;p&gt;这是一个普通段落&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块&lt;/code&gt;&lt;/pre&gt; Here is an example of AppleScript: tell application "Foo" beep end tell 会被Markdown转化成： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application "Foo" beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class="footer"&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被Markdown转为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ********** - - - ------------ 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 这是一个行内链接的例子 这是一个没有title的行内链接 MarkDown会产生： 这是一个[行内链接](http://example.com/ "链接的Title")的例子 这是一个没有title的[行内链接](http://example.com/) 如果是链接到同样主机的资源，可以使用相对路径：See my About page for detailsMarkdown会产生： See my [About](/about ) page for details 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：This is [an example] [id] reference-style link.Markdown产生： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]:http://example.com/ "Optional Title Here" 链接内容定义的形式为: 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接标记文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ "Optional Title Here" [foo]: http://example.com/ 'Optional Title Here' [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; "Optional Title Here" 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here "Optional Title Here" 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 参考式链接的好处： 使用 Markdown的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the `printf()` function. 会产生：Use the printf() function. 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： There is a literal backtick (`) here. 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any &lt;blink&gt; tags. &lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &amp;#8212; is the decimal-encodedequivalent of &amp;mdash;. 图片 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg "Optional title") 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法是这样的： ！[Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image "Optional title attribute" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 标签。 其他 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来： &lt;http://example.com/&gt; 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用&lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \*literal asterisks\* Markdown产出为： *literal asterisks* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[良好的编程习惯]]></title>
      <url>%2F%E8%89%AF%E5%A5%BD%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF.html</url>
      <content type="text"><![CDATA[习惯，是积久养成的生活方式，它能够使人们使用最少的精力，达成既定的某种结果。好的习惯，让我们不用花费太多精力在为什么这么做的思考上面，因为在养成这种好习惯的过程中，我们已经思考了原因，也明白这么做的好处，剩下的，照着做就是了。编程也需要良好的习惯，培养良好的编程习惯，让我们工作地更加高效。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[花绘一二幅]]></title>
      <url>%2F%E8%8A%B1%E7%BB%98%E4%B8%80%E4%BA%8C%E5%B9%85.html</url>
      <content type="text"><![CDATA[中午画了一幅水彩画：芍药花。 这是学习水彩花绘的第二幅作品。 第一幅是这样的： 对比一下，发现还是有点进步的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记住回家的路]]></title>
      <url>%2F%E8%AE%B0%E4%BD%8F%E5%9B%9E%E5%AE%B6%E7%9A%84%E8%B7%AF.html</url>
      <content type="text"><![CDATA[第一次读到这篇文章，是高中时做一篇语文阅读理解，一字一句读完，若有所悟。再次读，是在周国平《安静的位置》文集中。读周国平老师的文字，就好像在与一位从容淡然的智者交谈，特别是每次读到这篇文章，内心都无比沉静。在这里贴出原文，希望自己心猿意马、迷茫无助之时，有这样一口清泉洗涤我的心。 原文： 生活在今日的世界上，心灵的宁静不易得到。这个世界既充满着机会，也充满着压力。机会诱惑人去尝试，压力逼迫人去奋斗，都使人静不下心来。我不主张年轻人拒绝任何机会，逃避一切压力，以闭关自守的姿态面对世界。年轻的心灵本不该静如止水，波澜不惊。世界是属于年轻人的，趁着年轻到广阔的世界上去闯荡一番，原是人生必要的经历。所须防止的只是，把自己完全交给了机会和压力去支配，在世界上风风火火或浑浑噩噩，迷失了回家的路途。 每到一个陌生的城市，我的习惯是随便走走，好奇心驱使我去探寻这里的热闹的街巷和冷僻的角落。在这途中，难免暂时地迷路，但心中一定要有把握，自信能记起回住处的路线，否则便会感觉不踏实。我想，人生也是如此。你不妨在世界上闯荡，去建功立业，去探险猎奇，去觅情寻爱，可是，你一定不要忘记了回家的路。这个家，就是你的自我，你自己的心灵世界。 寻求心灵的宁静，前提是首先要有一个心灵。在理论上，人人都有一个心灵，但事实上却不尽然。有一些人，他们永远被外界的力量左右着，永远生活在喧闹的外部世界里，未尝有真正的内心生活。对于这样的人，心灵的宁静就无从谈起。一个人惟有关注心灵，才会因为心灵被扰乱而不安，才会有寻求心灵的宁静之需要。所以，具有过内心生活的禀赋，或者养成这样的习惯，这是最重要的。有此禀赋或习惯的人都知道，其实内心生活与外部生活并非互相排斥的，同一个人完全可能在两方面都十分丰富。区别在于，注重内心生活的人善于把外部生活的收获变成心灵的财富，缺乏此种禀赋或习惯的人则往往会迷失在外部生活中，人整个儿是散的。自我是一个中心点，一个人有了坚实的自我，他在这个世界上便有了精神的坐标，无论走多远都能够找到回家的路。换一个比方，我们不妨说，一个有着坚实的自我的人便仿佛有了一个精神的密友，他无论走到哪里都带着这个密友，这个密友将忠实地分享他的一切遭遇，倾听他的一切心语。 如果一个人有他的心灵追求，又在世界上闯荡了一番，有了相当的人生阅历，那么，他就会逐渐认识到自己在这个世界上的位置。世界无限广阔，诱惑永无止境，然而，属于每一个人的现实可能性终究是有限的。你不妨对一切可能性保持着开放的心态，因为那是人生魅力的源泉，但同时你也要早一些在世界之海上抛下自己的锚，找到最适合自己的领域。一个人不论伟大还是平凡，只要他顺应自己的天性，找到了自己真正喜欢做的事，并且一心把自己喜欢做的事做得尽善尽美，他在这个世界上就有了牢不可破的家园。于是，他不但会有足够的勇气去承受外界的压力，而且会有足够的清醒来面对形形色色的机会或诱惑。我们当然没有理由怀疑，这样的一个人必能获得生活的充实和内心的宁静。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[胡言乱语]]></title>
      <url>%2F%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD.html</url>
      <content type="text"><![CDATA[我敲击着键盘在代码之间游弋那不是我的向往如道具一般的工作开发着别人眼中的生活 我不是勤恳的工人无私奉献毛孔中的火热不能与金钱为敌只希望梦想不会进入坟地 我拿起画笔信手涂鸦多数只是以失望收场耐心是我的敌人激情和创意是我的短板 我试着在镜头里写情书不管是甘甜还是苦涩花草，虫鱼，枯枝，残影都成了落寞的情话 我唱起红尘的歌忘我地演绎着悲伤的快乐怕是歌词太应景预言里有一个可笑的侬 剩下的我用捡来的文字堆砌所谓的诗歌这是我虚伪的满足打发物质追求之外的空虚用胡言乱语，装饰自己的清高和粗俗]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开篇]]></title>
      <url>%2F%E6%96%B0%E7%9A%84%E5%BC%80%E7%AF%87.html</url>
      <content type="text"><![CDATA[今天是2015年9月1日，是学生们开学的日子。我也在今天正式开启了我的Hexo个人主页。 功夫不负有心人老早就想拥有一个属于自己的个人主页，尽管在LOFTER、网易博客、CSDN、开源中国、简书等平台都曾经注册过账号,但是总感觉杂而乱，每次登陆哪些平台，总能被其他用户的内容所吸引，而并不能集中精力在自己的事情上。 于是乎，趁着八月份工作清闲，我尝试着学习使用Hexo+GitHub搭建自己的个人主页。经过两个多星期的摸索，终于在上周搭建好了。 路漫漫其修远兮，吾将上下而求索说实话，虽然上周就把博客搭建好了，但是一直没有在上面写东西。主要是没有花心思去学Markdown语法。今天呢，决定正式开始这个博客的写作之旅。 关于为什么用Markdown写作，看这里。我选择下载安装Cmd Markdown编辑软件来编辑文本。 OK，既然选择了这样一条折腾的道路，就继续折腾下去吧。]]></content>
    </entry>

    
  
  
</search>
